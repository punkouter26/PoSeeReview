using Microsoft.Extensions.Logging;
using Po.SeeReview.Core.Interfaces;
using SixLabors.Fonts;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Drawing.Processing;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;

namespace Po.SeeReview.Infrastructure.Services;

/// <summary>
/// Service for overlaying readable text onto comic images generated by DALL-E.
/// DALL-E 3 cannot generate correct English letters/words, so this service adds speech bubbles
/// with real readable text after the base image is generated. This ensures all dialogue is legible.
/// </summary>
public class ComicTextOverlayService : IComicTextOverlayService
{
    private readonly IAzureOpenAIService _azureOpenAIService;
    private readonly ILogger<ComicTextOverlayService> _logger;

    public ComicTextOverlayService(
        IAzureOpenAIService azureOpenAIService,
        ILogger<ComicTextOverlayService> logger)
    {
        _azureOpenAIService = azureOpenAIService ?? throw new ArgumentNullException(nameof(azureOpenAIService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Extracts dialogue from narrative and overlays it onto comic image
    /// </summary>
    /// <param name="imageBytes">Original comic image from DALL-E</param>
    /// <param name="narrative">Story narrative</param>
    /// <param name="panelCount">Number of panels in the comic</param>
    /// <returns>Modified image bytes with text overlay</returns>
    public async Task<byte[]> AddTextOverlayAsync(byte[] imageBytes, string narrative, int panelCount)
    {
        if (imageBytes == null || imageBytes.Length == 0)
            throw new ArgumentException("Image bytes cannot be empty", nameof(imageBytes));

        if (string.IsNullOrWhiteSpace(narrative))
            throw new ArgumentException("Narrative cannot be empty", nameof(narrative));

        _logger.LogInformation("Adding text overlay to {PanelCount}-panel comic", panelCount);

        try
        {
            // Extract dialogue suggestions from narrative using GPT
            var dialogues = await ExtractDialogueAsync(narrative, panelCount);

            if (dialogues == null || dialogues.Count == 0)
            {
                _logger.LogInformation("No dialogue extracted, returning original image");
                return imageBytes;
            }

            // Load image and add text overlays
            using var image = Image.Load<Rgba32>(imageBytes);
            using var outputStream = new MemoryStream();

            // Calculate panel dimensions (1792x1024 image)
            var panelPositions = CalculatePanelPositions(image.Width, image.Height, panelCount);

            // Load font for text rendering
            var font = GetComicFont(24);

            // Draw text on each panel - ENSURE we have dialogue for every panel
            var finalDialogues = dialogues.ToList();
            
            // Pad with fallback text if we don't have enough dialogues
            while (finalDialogues.Count < panelCount)
            {
                finalDialogues.Add($"Panel {finalDialogues.Count + 1}");
            }

            // Draw text on each panel
            for (int i = 0; i < Math.Min(panelCount, panelPositions.Count); i++)
            {
                var dialogueText = i < finalDialogues.Count ? finalDialogues[i] : $"Panel {i + 1}";
                
                if (string.IsNullOrWhiteSpace(dialogueText))
                {
                    dialogueText = "..."; // Use ellipsis for empty panels
                }

                var position = panelPositions[i];
                DrawTextBubble(image, dialogueText, position, font);
                
                _logger.LogDebug("Added text bubble to panel {PanelNumber}: {Text}", i + 1, dialogueText);
            }

            // Save modified image
            image.SaveAsPng(outputStream);
            var modifiedBytes = outputStream.ToArray();

            _logger.LogInformation("Added {Count} text overlays to comic image", dialogues.Count);
            return modifiedBytes;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to add text overlay, returning original image");
            return imageBytes; // Return original on failure
        }
    }

    /// <summary>
    /// Extracts dialogue from narrative - creates one dialogue line per panel
    /// </summary>
    private async Task<List<string>> ExtractDialogueAsync(string narrative, int panelCount)
    {
        // For now, split the narrative into parts based on panel count
        // In a future version, this could use GPT to generate panel-specific dialogue
        
        try
        {
            // Simple approach: Split narrative into sentences and distribute across panels
            var sentences = narrative.Split(new[] { '.', '!', '?' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(s => s.Trim())
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .ToList();

            var dialogues = new List<string>();

            if (sentences.Count == 0)
            {
                // Fallback: create generic captions
                for (int i = 0; i < panelCount; i++)
                {
                    dialogues.Add($"Panel {i + 1}");
                }
                return dialogues;
            }

            // Distribute sentences across panels
            if (sentences.Count >= panelCount)
            {
                // We have enough sentences - take one per panel
                dialogues = sentences.Take(panelCount).ToList();
            }
            else
            {
                // Fewer sentences than panels - repeat or split
                dialogues = sentences.ToList();
                while (dialogues.Count < panelCount)
                {
                    dialogues.Add(sentences[dialogues.Count % sentences.Count]);
                }
            }

            // No truncation - let text wrap naturally in the bubble

            _logger.LogInformation("Extracted {Count} dialogue lines for {PanelCount} panels", 
                dialogues.Count, panelCount);

            return dialogues;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to extract dialogue from narrative");
            
            // Fallback: create simple captions based on panel number
            var fallbackDialogues = new List<string>();
            for (int i = 0; i < panelCount; i++)
            {
                fallbackDialogues.Add($"Scene {i + 1}");
            }
            return fallbackDialogues;
        }
    }

    /// <summary>
    /// Calculates center positions for each panel based on layout
    /// </summary>
    private List<PointF> CalculatePanelPositions(int width, int height, int panelCount)
    {
        var positions = new List<PointF>();

        switch (panelCount)
        {
            case 1:
                // Single panel - center
                positions.Add(new PointF(width / 2f, height * 0.75f));
                break;

            case 2:
                // Two panels stacked vertically
                positions.Add(new PointF(width / 2f, height * 0.33f));
                positions.Add(new PointF(width / 2f, height * 0.75f));
                break;

            case 3:
                // Three panels horizontal
                positions.Add(new PointF(width * 0.17f, height * 0.75f));
                positions.Add(new PointF(width * 0.50f, height * 0.75f));
                positions.Add(new PointF(width * 0.83f, height * 0.75f));
                break;

            case 4:
            default:
                // Four panels in 2x2 grid
                positions.Add(new PointF(width * 0.25f, height * 0.33f)); // Top-left
                positions.Add(new PointF(width * 0.75f, height * 0.33f)); // Top-right
                positions.Add(new PointF(width * 0.25f, height * 0.75f)); // Bottom-left
                positions.Add(new PointF(width * 0.75f, height * 0.75f)); // Bottom-right
                break;
        }

        return positions;
    }

    /// <summary>
    /// Draws a text bubble with background at specified position
    /// </summary>
    private void DrawTextBubble(Image<Rgba32> image, string text, PointF position, Font font)
    {
        // Calculate appropriate wrapping width based on panel width
        // For 1792x1024 image with up to 4 panels, allow generous wrapping
        var maxWrappingWidth = 400; // Increased from 300 to allow full sentences
        
        // Measure text size
        var textOptions = new RichTextOptions(font)
        {
            Origin = position,
            HorizontalAlignment = HorizontalAlignment.Center,
            VerticalAlignment = VerticalAlignment.Center,
            WrappingLength = maxWrappingWidth
        };

        var textBounds = TextMeasurer.MeasureBounds(text, textOptions);

        // Draw white rounded rectangle background with more padding
        var padding = 15; // Increased padding for better readability
        var bubbleRect = new RectangleF(
            textBounds.X - padding,
            textBounds.Y - padding,
            textBounds.Width + (padding * 2),
            textBounds.Height + (padding * 2)
        );

        image.Mutate(ctx =>
        {
            // Draw bubble background
            ctx.Fill(Color.White, bubbleRect);
            ctx.Draw(Color.Black, 3, bubbleRect); // Slightly thicker border for visibility

            // Draw text
            ctx.DrawText(textOptions, text, Color.Black);
        });
    }

    /// <summary>
    /// Gets a comic-style font for text rendering
    /// </summary>
    private Font GetComicFont(int size)
    {
        try
        {
            // Try to use Comic Sans MS or Arial, or fall back to first available font
            var fontFamily = SystemFonts.Families.FirstOrDefault(f => 
                f.Name.Contains("Comic", StringComparison.OrdinalIgnoreCase) ||
                f.Name.Contains("Arial", StringComparison.OrdinalIgnoreCase));

            var selectedFamily = fontFamily.Name != null ? fontFamily : SystemFonts.Families.First();
            return selectedFamily.CreateFont(size, FontStyle.Bold);
        }
        catch
        {
            // Fallback to any available font
            return SystemFonts.CreateFont(SystemFonts.Families.First().Name, size, FontStyle.Bold);
        }
    }
}
