using Microsoft.Extensions.Logging;
using Po.SeeReview.Core.Interfaces;
using SixLabors.Fonts;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Drawing.Processing;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;

namespace Po.SeeReview.Infrastructure.Services;

/// <summary>
/// Service for overlaying readable text onto comic images generated by DALL-E.
/// DALL-E 3 cannot generate correct English letters/words, so this service adds speech bubbles
/// with real readable text after the base image is generated. This ensures all dialogue is legible.
/// </summary>
public class ComicTextOverlayService : IComicTextOverlayService
{
    private readonly IAzureOpenAIService _azureOpenAIService;
    private readonly ILogger<ComicTextOverlayService> _logger;

    public ComicTextOverlayService(
        IAzureOpenAIService azureOpenAIService,
        ILogger<ComicTextOverlayService> logger)
    {
        _azureOpenAIService = azureOpenAIService ?? throw new ArgumentNullException(nameof(azureOpenAIService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Extracts dialogue from narrative and overlays it onto comic image
    /// </summary>
    /// <param name="imageBytes">Original comic image from DALL-E</param>
    /// <param name="narrative">Story narrative</param>
    /// <param name="panelCount">Number of panels in the comic</param>
    /// <returns>Modified image bytes with text overlay</returns>
    public async Task<byte[]> AddTextOverlayAsync(byte[] imageBytes, string narrative, int panelCount)
    {
        if (imageBytes == null || imageBytes.Length == 0)
            throw new ArgumentException("Image bytes cannot be empty", nameof(imageBytes));

        if (string.IsNullOrWhiteSpace(narrative))
            throw new ArgumentException("Narrative cannot be empty", nameof(narrative));

        _logger.LogInformation("Adding text overlay to {PanelCount}-panel comic", panelCount);

        try
        {
            // Extract dialogue suggestions from narrative using GPT
            var dialogues = await ExtractDialogueAsync(narrative, panelCount);

            if (dialogues == null || dialogues.Count == 0)
            {
                _logger.LogInformation("No dialogue extracted, returning original image");
                return imageBytes;
            }

            // Load image and add text overlays
            using var image = Image.Load<Rgba32>(imageBytes);
            using var outputStream = new MemoryStream();

            // Load font for text rendering
            var font = GetComicFont(20); // Slightly smaller font for single box

            // Combine all dialogue into a single narrative text
            var combinedText = string.Join(" ", dialogues.Where(d => !string.IsNullOrWhiteSpace(d)));
            
            if (string.IsNullOrWhiteSpace(combinedText))
            {
                combinedText = narrative; // Fall back to full narrative
            }

            // Draw single text box at top center of entire comic
            var topCenterPosition = new PointF(image.Width / 2f, 40); // 40px from top
            DrawTextBubble(image, combinedText, topCenterPosition, font);
            
            _logger.LogDebug("Added single text overlay at top: {Text}", combinedText);

            // Save modified image
            image.SaveAsPng(outputStream);
            var modifiedBytes = outputStream.ToArray();

            _logger.LogInformation("Added {Count} text overlays to comic image", dialogues.Count);
            return modifiedBytes;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to add text overlay, returning original image");
            return imageBytes; // Return original on failure
        }
    }

    /// <summary>
    /// Extracts dialogue from narrative - creates one dialogue line per panel
    /// </summary>
    private Task<List<string>> ExtractDialogueAsync(string narrative, int panelCount)
    {
        // For now, split the narrative into parts based on panel count
        // In a future version, this could use GPT to generate panel-specific dialogue
        
        try
        {
            // Simple approach: Split narrative into sentences and distribute across panels
            var sentences = narrative.Split(new[] { '.', '!', '?' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(s => s.Trim())
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .ToList();

            var dialogues = new List<string>();

            if (sentences.Count == 0)
            {
                // Fallback: create generic captions
                for (int i = 0; i < panelCount; i++)
                {
                    dialogues.Add($"Panel {i + 1}");
                }

                return Task.FromResult(dialogues);
            }

            // Distribute sentences across panels
            if (sentences.Count >= panelCount)
            {
                // We have enough sentences - take one per panel
                dialogues = sentences.Take(panelCount).ToList();
            }
            else
            {
                // Fewer sentences than panels - repeat or split
                dialogues = sentences.ToList();
                while (dialogues.Count < panelCount)
                {
                    dialogues.Add(sentences[dialogues.Count % sentences.Count]);
                }
            }

            // No truncation - let text wrap naturally in the bubble

            _logger.LogInformation("Extracted {Count} dialogue lines for {PanelCount} panels", 
                dialogues.Count, panelCount);

            return Task.FromResult(dialogues);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to extract dialogue from narrative");
            
            // Fallback: create simple captions based on panel number
            var fallbackDialogues = new List<string>();
            for (int i = 0; i < panelCount; i++)
            {
                fallbackDialogues.Add($"Scene {i + 1}");
            }

            return Task.FromResult(fallbackDialogues);
        }
    }

    /// <summary>
    /// Calculates center positions for each panel based on layout
    /// </summary>
    private List<PointF> CalculatePanelPositions(int width, int height, int panelCount)
    {
        var positions = new List<PointF>();

        switch (panelCount)
        {
            case 1:
                // Single panel - center
                positions.Add(new PointF(width / 2f, height * 0.75f));
                break;

            case 2:
                // Two panels side-by-side horizontally
                positions.Add(new PointF(width * 0.25f, height * 0.75f)); // Left panel
                positions.Add(new PointF(width * 0.75f, height * 0.75f)); // Right panel
                break;

            case 3:
                // Three panels horizontal
                positions.Add(new PointF(width * 0.17f, height * 0.75f));
                positions.Add(new PointF(width * 0.50f, height * 0.75f));
                positions.Add(new PointF(width * 0.83f, height * 0.75f));
                break;

            case 4:
            default:
                // Four panels in 2x2 grid
                positions.Add(new PointF(width * 0.25f, height * 0.33f)); // Top-left
                positions.Add(new PointF(width * 0.75f, height * 0.33f)); // Top-right
                positions.Add(new PointF(width * 0.25f, height * 0.75f)); // Bottom-left
                positions.Add(new PointF(width * 0.75f, height * 0.75f)); // Bottom-right
                break;
        }

        return positions;
    }

    /// <summary>
    /// Draws a text bubble with background at specified position
    /// </summary>
    private void DrawTextBubble(Image<Rgba32> image, string text, PointF position, Font font)
    {
        // For top-center placement, allow wide wrapping (most of image width)
        var maxWrappingWidth = (int)(image.Width * 0.9); // 90% of image width
        
        // Measure text size
        var textOptions = new RichTextOptions(font)
        {
            Origin = position,
            HorizontalAlignment = HorizontalAlignment.Center,
            VerticalAlignment = VerticalAlignment.Top, // Align to top so box grows downward
            WrappingLength = maxWrappingWidth
        };

        var textBounds = TextMeasurer.MeasureBounds(text, textOptions);

        // Draw white rounded rectangle background with more padding
        var padding = 15; // Increased padding for better readability
        var bubbleRect = new RectangleF(
            textBounds.X - padding,
            textBounds.Y - padding,
            textBounds.Width + (padding * 2),
            textBounds.Height + (padding * 2)
        );

        image.Mutate(ctx =>
        {
            // Draw bubble background
            ctx.Fill(Color.White, bubbleRect);
            ctx.Draw(Color.Black, 3, bubbleRect); // Slightly thicker border for visibility

            // Draw text
            ctx.DrawText(textOptions, text, Color.Black);
        });
    }

    /// <summary>
    /// Gets a comic-style font for text rendering
    /// </summary>
    private Font GetComicFont(int size)
    {
        try
        {
            var families = SystemFonts.Families.ToList();
            if (families.Count == 0)
            {
                _logger.LogWarning("No system fonts available, text overlay will be skipped");
                throw new InvalidOperationException("No fonts available");
            }
            
            // Try to use Comic Sans MS, Arial, DejaVu, Liberation, or fall back to first available font
            var fontFamily = families.FirstOrDefault(f => 
                f.Name.Contains("Comic", StringComparison.OrdinalIgnoreCase) ||
                f.Name.Contains("Arial", StringComparison.OrdinalIgnoreCase) ||
                f.Name.Contains("DejaVu", StringComparison.OrdinalIgnoreCase) ||
                f.Name.Contains("Liberation", StringComparison.OrdinalIgnoreCase));

            var selectedFamily = fontFamily.Name != null ? fontFamily : families.First();
            return selectedFamily.CreateFont(size, FontStyle.Bold);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to get font, will skip text overlay");
            throw;
        }
    }
}
